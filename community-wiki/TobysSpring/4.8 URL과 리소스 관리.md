# 4.8 URL과 리소스 관리 
## 디폴트 서디풀트 서블릿과URL 매핑문제

URL을 통해 접근할 수 이는 웹을 분류하면
	정적리소스: html,js, css
	동적인: jsp, 스프링mvc
%  URL은 동적인것과 정적인것을 구분하지 않고, 경로와 이름을 조합
    .do 같은 확장자로 했지만 최근에는 확장자 없이 /user/add , /user/1/edit 등과같이 사용
~~~
1 확장자를 쓰는 예전방식
	<servlet>
	<servlet-name>appServlet<lservlet-name>
	<servlet-class>Org.springframework .web.servlet .DispatcherServlet<servlet-class>
	<Isevlet>
	<servlet-mapping>
	<servlet-name>spring<lservlet-name>
	<servlet-name>*.do</servlet-name>
	</servlet>

2. 확장자를 안쓰는 요즘방식

	<servlet>
	<servlet-name)spring<lservlet-name>
	<servlet-name)/app/*</servlet-name>	
	</servlet-mapping>
~~~


?: 2와 같은 방식이라면 js, css 같은 파일을 어떻게 구분하는 것인가면 web.xml에 확장자설정이 되어있다.
~~~

	<servlet>
	<servlet-name>default<lservlet-name>
	<servlet-class>Org .apache .catalina.servlets.Default5ervlet<lservlet-class>
	<load-on-startup>3</load-on-startup>
	</servlet>


	<servlet-mappin>
	<servlet-name>default<lservlet-name>
	<url-pattern)/</url-pattern>
	</servlet-mapping>



	<servlet>
	<servlet-name>isp</servlet-name>
	<servlet-class>Org.apache.iasper.servlet.JspServlet</servlet-class>
	< load-on-startup>1<load-on-startup>
	</servlet>

	<servlet>
	<servlet-name>isp</servlet-name>
	<url-pattern>*.isp</url-pattern>
	<url-pattern>*.ispx</url-pattern>
	</servlet-mapping>


~~~



jsp서블릿은 JspServlet으로 보내주고 나머지는 우선순위가 낮은 /로 보냄



### <mvc:default-servlet-handler/>

?: DispatcherServlet에 /로 매핑해버리면 web.xml에 설정된 DefaultServlet보다 우선시 됨
문제 해결은 다음과 같음

-> 서블릿 콘텍스트에 <mvc:default-servlet-handler/>를 넣으면 됨
   디스패처 서블릿으로 가는 것 같지만, 정적리소스파일에 대한 요청을 디폴트 서블릿으로 가게해줌



# 4.8.2 <url:resource/>를 이용한 리소스관리 


<url:resource>를 사용하면 정적파일도 라이브러리처럼 쓸 수 잇음

-> 모듈화된 리소스를 다루는 별도의 서블릿 만듬


메타정보나 리소스가 있으면 /META-INF에 다음과 같은 구조로 넣어주면 된다.
 
    META-INF/ webresources / ui  /  js
    				 / css
                                 / theme

서블릿 컨텍스트에 <mvc:resources mapping="/ui/** location="classpath:/META-INF/webresources"/  /> 추가

이렇게 해두면 /ui로 시작되는 요청이 들어왔을 경우 자동으로 webresources 아래의 파일로 매핑해줌
 * 1. location 애트리부트에 file, http를 넣으면 다른서버의 정보를 가져올 수 있음
 * 2. 2. 이미 등록해 놓은 리소스면 304코드를 보내 효율성을 높일 수 잇음

일부만 <mvc:resouces를 사용하고 나머지는 디폴트 서블릿을 사용 할 때는 <mvc:default-servlet-handler>를 사용하면 recources로 매핑이 안되는것만 디폴드로 보냄
<mvc:resources>는<mvc:default-servlet-handler> 보다 매핑 우선순위가 높다 .

### 4.9.1 새로운 RequestMapping 전략

636~636 기존의 리퀘스트 매핑은 문제점에대해 설명

핸들러 매핑은 HTTP의 요청정보를 이용해서 진입할 컨트롤러를 찾아주는 일을 담당한다.

스프링 이전 단계에서는 컨트롤 단위로 매핑했지만,  2.5부터 추세에 따라 메소드 단위로 매핑 가능해짐

그렇게 됨으로써 핸들러레벨의 매핑이 어려움, 메소드는 오브젝트로 취급되지 않으니 빈이 될 수가 없다.  3.0에서는 해결하기 위해 DefaultAnnotationHandlerMapping 전략에선 매핑 결과가 요청을 담당할 메소드가 속해 있는 컨트롤러의 오브젝트가 될 수밖에 없었다. 그래서 선정된 핸들러를 실행하는 책임만 맡아야 할 AnnotationMethodHandlerAdapter가 필요했음, 망함

public boolean preHandle(HttpServletRequest request, HttpServletResponse response,
Object handler) throws Exception; 

위에 것은 핸들러 인터셉턴인데 저기서 핸들러는 요청을 처리할 메소드의 메타정보를 얻을 수 있는데 컨트롤러 오브젝트 전체가 핸들러 매핑되버리니 정보를 얻을 수 없음.

* 결론적으로 핸들러 매핑과 어댑터 전략은 mvc핸들러가 컨트롤러 역활을 담당하는 빈 오브젝트라는 설계의 전제와, 메소드를 실행 가능한 핸들러 오브젝트 형태로 만들 수 없어서 이상할 수 밖에 없음



-> 3.1부터는 전달받은 핸들러를 HandlerMethod 타입으로 캐스팅하여 해결함

~~~
리스트 4-129 @Audit 애노테이션이 달린 @RequestMapping 메소드를 처리하는 핸들러 인터셉터
  @Autdit 애노테이션이 붙어있는 @Request메소드가 실행될 때마다 관련 정보를 파일에 저장
  
public class Auditlnterceptor extends HandlerlnterceptorAdapter {
@Override
  public boolean preHandle(HttpServletReQuest reQuest ,
  HttpServletResponse response, Object handler) throws Exception {

      HandlerMethod hm =(HandlerMethod)handler;
  if (hm .getMethodAnnotation(Audit .class) != null) {
		saveAuditlnfo(request, response, handler);
	}
	return super.preHandle(request, response , handler);
}
	private void saveAuditlnfo(HttpServletReQuest reQuest ,
	HttpServletResponse response , Object handler) {

	// 요청정보를 감사 용도의 외부 파일에 저장
	}
}
~~~

* HandlerMethod

HandlerMethod는 @RequestMapping 이 붙은 메소드의 정보를 추상화한 오브젝트 타입
이다.  컨트롤러 오브젝트 대신 추상화된 메소드 정보를 담은 오브젝트를 핸들러 매핑의
결과로 돌려주고，핸들러 어랩터는 HandlerMethod 오브젝트의 정보를 이용해 메소드를
실행한다.  * 실제 실행x 정보를 담고있는거 o

 % 그리고 실제로 쓰는 일도 없다고 한다. 

* 핸들러 메소드의 정보들

1.    빈 오브젝트

2.  메소드 메타정보

3.  메소드 파라미터정보

4. 메소드 애노테이션메타 정보

5. 리턴 값 메타정보

   ​

### @RequestMapping 전략   

-> 지금까지 설명한 HandfelMethd 기본 전략 아님, 이거 쓰려면 <mvc:annotation-driven>  등록

@RequestMapping 매핑정보를 다루는 전략 클래스는 RequestMappingHandlerMapping
이다. @RequestMappingHandlerMapping의 역활은 클라이언트의 요청을 @RequestMapping이 붙은 메소드로 매핑해주는 것



####요청조건

핸들러 매핑이 다루는 요청은 HTTP서블릿요청, 브라우저 같은 클라이언트가 HTTP 프로토콜을 이용해 보내는걸 말한다.

RequestMapping에 포한된 요청 조건들

~~~
엘리먼트: value,method, params, headfer, consumes,produces
요청조건: URL패턴, HTTP요청메소드, 파라미터, HTTP헤더, COntent-type헤더,ACCEPT헤더
~~~

##### 각 조건 요청이 조합하면 여러개가 만들어짐

~~~
리스트 4-131 URL 때턴 요청 조건 조합

@Controller
@RequestMapping({'/a' , '/b‘})
public class PatternController {
	@RequestMapping({"/c" , "/d"})
	public String hello() { ... }

}

예제2
@ReQuestMapping("'user")
public class U serController {
  @RequestMapping
public String add() { . .. }

~~~

~~~
리스트 4-132 파라미터 요청 조합

@Comtroller
@RequestMapping(params={'p1' , “p2"})
  public class ParamsController {
    @Request삐apping(params={"p3" ， "p4'})
    public String hello2() { ... }
}
~~~

1. url 조건 조합

* URL은 패턴이 하나 이상이면 OR로 연결됨,  리스트 4-131처럼 클래스와 메소드 양쪽에 패턴이 있는경우 클래스 메소드 순으로 /a/c, a/d, b/c, b/d의 네 가지 조합이 만들어진다. 


* 예제2 보며 클래스에 url걸려잇고 메소드는 없는데, 메소드에 get, post와 같은 조건을 건다
*  /hello랑 /hello/ 랑 다른데 useTrailingSlashMatch TRUE면 전자가 후자까지 포함한다. 디폴트는 TRUE

2. HTTP 요청방법 : RequestMethodsRequestCondition 

* 파라미터는 모든조건을 만족해야함  4-132 hello2가 실행되려면 에서 p1,p2,p3,p4를 만족해야함

* 헤더: HeadersRequestCondition

  Content-Type과 Accept 헤더는 headers 엘리먼트의
  값으로 넣는 것이 허용되긴 하지만 실제로 헤더 요청 조건이 아니라 다음에 소개할
  Context-Type 요청 조건과 Accept 요청 조건으로 취급된다.**이것도 AND조합**

* Content-Type 헤더: ConsumesRequestCondition 

   HTTP 요청의 헤더에 나오는 Content-Type은 요청의 내용이 어떤 형식인지를 알
려준다. GET으로 보내는 일반 요청은 Content-Type이 없지만. 

 <form>에 의해 요청
이 보내지는 경우에는 application/ x-www-form-urlencoded가 지정되고， 따일을 보
낼 때는 Content-Type 헤더가 multipart/form-data로 설정된다.

   AJAX를 이용해 JSON 바디를 가진 요청을 보내는 경우라면 Content-Type이 application/json이
될것이다. 

GET과 POST는 HTTP 요청 방법 조건이 있으니 굳이 Content-Type을 보고 구분
할 필요는 없다. 

사용방법 : @RequestMapping(consumes="application/json") = @RequestMapping(headers=’‘Content-Type=application/json")

​           

헤더조건은 AND로 연결

Content-type은 OR로 연결 : ContentType은 타입과 메소드 양쪽에 있으면 타입에 있는건 무시

ex)

~~~
예를 들어 다음과 같이 클래스와 메소드 양쪽에 consumes를 사용하면 클래
스에 지정된 두 가지 조건은 무시되고 메소드에 지정된 multipart/form-data와
application/json만 시용된다. 다른 요청 조건과 조합 방식에 차이가 있으니 주의
해야한다.

@Controller
@RequestMapping(consumes={"application/xml"’
"application/x-www-form-urlencoded"})
public static class ConsumersController (
ORequestMapping(consumes={"multipart/form-data" , "application/json"})
public void hello() { ... }

~~~

* Accept 헤더: ProducesRequestCondition : 

콘덴트 타입이랑 같고, headers대신에 produces엘리먼트 이용가능, 클라이언트가 받아들일 수 있는 미디어 타입을 지정하는 데 사용 



#  4.9.3 @RequestMapping 핸들러 어댑터 

### 파라미터 타입

* @Validated/@Valid

 모델의 값을 검증함, 제약 조건이 여러개 일경우

~~~
다음과 같이 groups를 이용해 적용 그룹을 지정해주면 name 필드의 @NotEmpty는 User그룹과 Admin 그룹 양쪽에 모두 적용 됨
@NotEmpty(groups={User .class , Admin.class})
String name;
http://annotations.tistory.com/95


@RequestMapping( . .. )
public String saveUser(@ModelAttribute("user") @Validated(User.class)User user) {
}
~~~

* UriComponentsBuilder 

UriComponentsBuilder는 코드에서 URL을 생성하거나 가공할때 씀.  예를 들어 REST 스타일주소가 있으면

String uri = ’ http://www.myshop.com/users/ ‘’ + userld "/orders/" + orderld;

ex1)

UriComponents uc = UriComponentsBuilder.fromUriString(
 "http://www.myshop.com/users/{user}/orders/{order}" ).build();
String uri = uc.expand(userld, orderld).encode().toUriString()) 

ex2) 

 UriComponents uc = UriComponentsBuilder.newlnstance()
​	.scheme( "http")
​	host( “www.myshop.com")
​	path("/users/{user}/orders/{order}")
​	build() ; 

ex3) 

 ServletUriComponentsBuilder ucb =
ServletUriComponentsBuilder.fromRequest(request)
.replaceQueryParam( "userld" , "(id}"). bui ld()
.expand ('123‘)
.encode() ; 



3.1 부터는 파라미터로도 사용 가능함

@RequestMapping( ... )
public String uri(UriComponentsBuilder uriComponentsBuilder) { 



* RedirectAttributes와 리다이렉트 뷰

새로운 URL을 다시보내라고 지시하는거, 파라미터를 추가하려면 "return:/result?status="+status;

이런식으로 써도 됨 

~~~
public String saveForm(@ModelAttribute("user") User user , Model model ) (
// user 데이터 저장， status 값 생성
model.addAttribute("status" , status);
return "redirect:/result";

RequestMapping("/save/{status}"){
public String saveForm(ilModelAttribute("user") User user) (
return 'redirect :/result/{status}‘;
}
~~~

~~~
리스트 4-136 리다이렉트 뷰에서 필요하지 않은 모댈 정보톨 삭제하는 방법
             사용했던 정보를  비우고 다시보냄
public String saveForm(@ModelAttribute("user") User user , Model model) (
model.asMap().clear();
model. addAttribute( "status" , status);
return "redirect:/ressult";

3.1이후부터는 모델대신에 

public String saveForm(odelAttribute("user") User user, RedirectAttributes ra) {
  ra.addAttribute("status" , status);
  return "redirect:/result";
}
~~~

* RedirectAttributes와 플래시 애트리뷰트 

~~~
public String saveForm( @ModelAttribute("user") User user , RedirectAttributesra) {
    ra.addFlashAttribute( "message" , "저장됐습니다");
    ra.addAttribute("status" ， status);
    return "redirect:/result“;
}
이렇게 저장된 플래시 애트리뷰트는 다음 GET 요청에서 자동으로 모텔에 추가된다.

{div class="flash_message"}
${message}
{/div}

~~~

### 

# 4.9.4 @EnableWebMvc와 WebMvcConfigurationSupport를 이용한 @MVC 설정 

659~

### @EnableWebMvc와 WebMvcConfigurer

@Configuration 클래스에 @EnableWebMvc를 붙여주면 <mvc:annotat ion-config/)을
XML에 넣었을 때와동일하게 스프링 3.1 의 최신 전략 빈이 등록된다. 

@ Enable 전용 애노태이션의 설정을 위해 사용되는 빈을 설정자 또는 컨
피규어러 configurer라고 한다.  

@Enab leWebMvc 의 빈 설정자가 구현해야 할 인터페이스는 WebMvcConfigurer 다. 

~~~
public interface WebMvcConfigurer (
	void addFormatters(FormatterRegistry registry);
	void configureMessageConverters(List<HttpMessageConverter<?>> converters);
	Validator getValidator();
	void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers);
	void addReturnValueHandlers(List<HandlerMethodReturnValueHandler> returnValueHandlers);
	void configureHandlerExceptionResolvers(List<HandlerExceptionResolver> exceptionResolvers);
	void addlnterceptors(InterceptorRegistry registry);
	void addViewControllers(ViewControllerRegistry registry);
	void addResourceHandlers(ResourceHandlerRegistry registry);
	void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) ;
}
~~~

* addFormattersO 

4.3.2 절에서 설명한 대로 포매터는 문자열로 된 폼 값과 모댈 오브젝트의 프로퍼티
사이의 변환 작업을 지원해주는 MVC용 컨버터다. 

~~~
@Auowired UserService userService;

@ßean
public UserFormatter userFormatter() (
	return new UserFormatter(userService);
}

or

@Autowired UserFormatter userFormatter;
---------------------------------

public void addFormatters(FormatterRegistry registry) (
	registry.addFormatter(userFormatter());
}


~~~

* configureMessageConvertersO 

메세지 컨버터 직접 구혀하고 싶다면 이거를 스면 됨

~~~
이것도 마찬가지로 빈을 먼저 생성하고 넣어주면 됨

ex) JSON 메시지를 위한 MappingJacksonHttpMessageConverter와 직접 구현한 메시지 컨버터만 사용하겠다면 다음과 같이 작성하면 된다.

public void configureMessageConverters(
    List<HttpMessageConverter<?>> converters) (
    converters.add(new MappingJacksonHttpMessageConverter());
    converters.add(new MyMessageConverter());
}
~~~

* getValidator()       검증기,  사용할일 없다고 함
* addArgumentResolvers()

RequestMappingHandlerAdapter 의 파라미 터 처 리용 확장 포인트인
HandlerMethodArgumentResolver를 추가할 수 있는 메소드다. 디폴트 파라미터 타
입이나 애노테이션 외에 새로운 파라미터 종류를 지원할 경우에 시용한다. 



* addReturnValueHandlers() 

RequestMappingHandlerAdapter 의 리 턴 값 처 리용 확장 포인트인
HandlerMethodReturnValueHandler를 추가할 때 사용한다. 새로운 리턴 값 처리 방
식을 추가하려면 이 메소드를 이용하면 된다. 



* configureHandlerExceptionResolvers() 

디폴트로 등록되는 핸들러 예외 전략을 새롭게 구성하려고 할 때 사용한다. 메시지
컨버터와 마찬가지로 이 메소드에서 핸들러 예외 리졸벼를 추가하면 디폴트 예외 리
졸버는무시된다. 



* addlnterceptors() 

인터셉터를 등록해주는 <mvc:interceptors)의 자바 코드 버전이다. 

InterceptorRegistry는 addlnterceptor() 와 addWebRequestlnterceptor() 메
소드를 통해 각각 Handlerlnterceptor와 WebRequestlnterceptor 타입의 인터셉터
를등혹하게해준다. 

* addViewControllers() : URL 패턴을 그대로 뷰 이름으로 돌려주는 간단한 컨트롤러를 등록하는 메소드다. 

  ​

* addResourceHandlers()

 스프링 3.0.4에서 추가된 <mvc:resources>의 기능을 담당히는 메소드다 

xml에서 이거였고<mvc:resources mapping="/ui/**" location="classpath:/META-INF/webresources/’‘ />

구현은 요렇게

public void addResourceHandlers(ResourceHandlerRegistry registry) {
registry .addResourceHandler( “/ui/**" )
.addResourceLocations("classpath:/META-INF/webresourcesl“);

}

### @MVC 설정자 빈 등록 방법

~~~
리스트 4-139 @Bean을 이용한 @EnableWebMvc 설정자 빈 등록

@Configuration
@EnableWebMvc
public class AppConfig (
	@Bean
	public WebMvcConfiguer webMvcConfigurer() (
		return new MyWeb삐vcConfigurer();
	}
}
public class MyWebMvcConfigurer implements WebMvcConfigurer {

}

최종
@Configuration
@EnableWebMvc
public class WebConfig extends WebMvcConfigurerAdapter (
	@ßean
	public WebMvcConfiguer securityConfigurer() (
	return new SecurityConfigurer();
	}
  @ßean
  public WebMvcConfiguer customerHandlerConfigurer() (
  	return new CustomerHandlerConfigurer();
  }
}

~~~



#  5.1 애스팩트 AOP

## 5.1.1 프록시기반 AOP

토비 스프링 VOL1에서 프록시, 데코레이터 패턴 이용해서 복잡하게 AOP 썼는데, 스프링에서 그냥 가져다 쓸수 있음

aop: 용어정리 http://credemol.blogspot.kr/2010/04/aop.html

* 1. AOP 인터페이스 구현과 aop 네입스쩨이스의 (aop:advisor) 태그를 이용하는 방법 

~~~
리스트 5-1 AOP 스키마의 태그룰 이용한 AOP 설정

<aop :config>
<aop:advisor advice-ref="transactionAdvice" pointcut="bean(*Service)" />
</ao p:config>

<bean id="transactionAdvice'’ class=" ... "). .. </bean>
~~~

* 2.임의의 자바 클래스와 aop 네임스페이스의 <aop :aspect>를 이용하는 방법 

어드바이스 어드바이저 대신 에스펙트라는 개념을 씀, 에스펙트는 독립적인 aop 모듈

애스펙트는 기본적으로 일반 자바 클래스를 이용해 정의할 수 있다. 애스펙트는
특정 인터페이스를 구현할 필요가 없다. 애노테이 션을 이용하거나 XML의 <aop:
aspectj > 태그를 이용해서 펑범한 자바 클래스를 AOP 애스펙트로 만들 수 있다. 인
터페이스를 구현히는 제약조건이 없으므로 메소드는 유연하게 정의할 수 있고， 하나
의 클래스 안에 여러 개의 애스펙트를 포함할 수도 있다. 



* 3.@AspectJ 애노테이션을 이용한 애스펙트 개발 방법

@AspectJ는 이름 그대로 AspectJ AOP 프레임워크에서 정의된 애노테이션을 이용
해 애스펙트를 만들 수 있게 해준다. 하지만 @AspectJ 문법과 애스펙트 정의 방법
을 차용했을 뿐， AspectJ AOP를 시용하는 것은 아니다. @AspectJ도 여타 방법과
동일하게 스프링의 프록시 기반 AOP를 만들 때 사용한다. 



** 각 사용용도: 1번이 가장 쉽다. 애스팩트를 이용한 방법은 유연한 대신 어렵다.  

​      XML선호하면 2번, 애노태이션  선호하면 3번 **



### 자동프록시 생성기와 프록시 빈
AOP는 무조건 프록시패턴을 사용해서 구현되어있다. 
** 여기서는 프록시를 만드는 방법에 따라 등록되는 빈의 종류와 사용 방법을 생각해보자. 
 
 여기에 프록시를 이용해서 Client와 Target의 코드에는 전혀
영향을 주지 않은 채로 Cl ient가 Target을 이용히는 과정에서 부가기능을 제공하도록
만들려고 한다. 이때 전제조건은 Cl ient가 Target을 직접 알고 있으면 안 된다는 것이
다. 즉 다음과 같이 Dl 하는 관계여서는 안 된다.

%DI: 의존성 주입

http://blog.naver.com/z1004man/220601593280

@Autowired나 이런식으로 주입해서 써먹는거

~~~
public class Client {
@Autowired Target target;
}
public class Target { .. . }

~~~

안 될까? 간단히 설명하자면 프록시는 Dl에 기반을 두고 있고， 위의 묘드는 Dl를
위반하고 있기 때문이다. 클라이언트가 자신이 사용할 오브젝트의 클래스를 알고있기 때문이다
(이렇게하면  Client가 시용할 오브젝트를 DI 컨테이너와 설정을 통해 바꿀 수 없기 때문이다.)

Client가 Target이라는 구체 클래스를 직접 의존하는 대신 Target이 구현하
고 있는 인터페이스를 이용해 의존하도록 만들어야 한다. 



~~~
public class Client {
	@Autowired Interface intf;
}
interface Interface { ... }
public class Target implements Interface { .. . }

프록시 구현
public class Proxy implements Interface (
  private Interface next;
  public void setNext(Interface next) { this.next =next; }
}
~~~

Proxy는 Interface 인터페이스를 구현했으므로 client에 주입 가능하다.DI 설정을
조작해서 Client • Proxy • Target 순서로 의존관계를 맺게 하면 Proxy가 Cl ient와
Target의 호출 과정에 끼어들어서 부가기능을 제공할 수 있게 된다. 

위의 코드는 @Autowired 사용이 불가해짐, Interface를 구현한 클래스가 두 개이기 때문에 @Qulifier 등을 사용해야한다.


그렇다면 프록시를 자동 프록시 생성이라는 기법을 이용해 AOP로 확장해준 경우에는 어떨까? 프록시 자체는 AOP가 아니다.
AOP는 하나의 모률을 많은 오브젝트， 정확히 말하자면 오브젝트의 메소드 실행 시점에 일괄 적용할 수 있어야 한다. 


그래서 스프링은 자동 프록시 생성기를 이용해서 컨테이너 초기화 중에 만들어진 빈을 바꿔치기해 프록시 빈을 자동으로 등록해준다. 빈을 선택히는 로직은 포인트컷을 이용하면 되고， XML이나 애노테이션을 통해 이미 정의된 빈의 의존관계를 바꿔치기하는 것은 빈 후처리기를 사용한다.이 자동 프록시 생성기가 바로 스프링의 프록시 기반 AOP의 핵심 동작원리다.


** 수동프록시와 자동프록시의 차이점:
자동 프록시 생성기는 프록시 빈을 별도로 추가하고 DI 설정만 바꿔주는 게 아니라 프록시를 적용할 대상 자체를 아예 자신이 포장해서 마치 그 빈처럼 동작한다는 점이다. 따라서 자동 프록시 생성기가 만들어주는 프록시는 새로운 빈으로추가되는 것이 아니라 AOP 대상타깃 빈을 대체한다. 
수동) client → proxy → target 자동)  client → proxy(target)
 Proxy가 Client와 Target 사이에 DI를 통해 끼어들어서 부가기능을 제공해줄 수 있는 기회를 만들어준 셈이니 다를 바 없어 보일지 모르겠다.  하지만 중요한 차이가 있다. 등록된 빈의 관점으로 볼 때 자동 프록시 생성기 방식에서는Target 오브젝트가 빈으로 직접 노출되지 않는다는 점이다.


**  자동프록시의 특징스프링에서 적용되는 AOP는 다 자동프록시라 특징을 잘 기억해야한다
1. AOP 적용은 @Autowired의 타입에 의한 의존관계 설정에 문제톨 일으키지 않는다
2. AOP 적용은 다른 클라이언드 들이 Target 오브젝트에 직접 의존하지 못하게 한다.   
~~~   
ex) public class Client2 {     @Autowired Target target;   에러남~~~      수동) client → proxy → target ← client2 자동)  client → proxy(target)  ←(불가) client2
