# 1장.	IoC 컨테이너와 DI
## 1.1 IoC 컨테이너: 빈팩토리와 애플리케이션 컨텍스트

#### *	IoC (Injection of Control(제어의 역전))  
~~~
:객체의 생성, 생명주기의 관리까지 모든 객체에 대한 제어권이 바뀜.
 ( 개발자 관리(x) -> 프레임 워크 )
 
 1. DL(Dependency Lookup): EJB, Spring ( 특정 컨테이너에 종속되어 잘 쓰이지 않음 )
 2. DI(Dependency Injection): Spring, Pico Container ( XML , Annotation 이용 )
                         각 클래스 간의 의존관계를 빈설정하여 컨테이너가 자동 연결 
                         Setter Injection, Constructor Injection, Method Injection
                         
->	Set Method: <property>를 통해 값 주입,생성자: <constructor-arg>를 통해 값을 주입.
~~~

#### *	IoC 컨테이너
~~~
: 스프링 애플리케이션에서 객체 생성, 관계 설정, 사용, 제거를 코드 대신 독립된 컨테이너가 당담함. 
(스프링 컨테이너 = IoC 컨테이너)

  1.BeanFactory: 객체 생성과 객체 사이의 런타임 관계 설정하는 DI 관점
  2.ApplicationContext: DI를 위한 빈 팩토리 + 엔터프라이즈 애플리케이션을 개발하는 데 필요한 여러 기능 추가, 
    BeanFactory를 상속한 서브 인터페이스 ( ≒ 스프링의 IoC 컨테이너 )
    
Cf) 엔터프라이즈 애플리케이션: 지속적으로 데이터 처리, 막대한 양의 데이터 처리, 
여러 사람이 동시에 데이터에 접근, 많은 데이터를 처리하기 위한 인터페이스 화면의 수가 많음, 
다른 엔터프라이즈 애플리케이션과 통합해 사용.
~~~

### 1.1.1	IoC 컨테이너를 이용해 애플리케이션 만들기 
 ~~~
 *StaticAppication ac=new StaticApplicationContext();  //빈 컨테이너 구현 
   + POJO 클래스 + 설정 메타정보 			//IoC컨테이너로 동작하기 위해 구현
= IoC 컨테이너
~~~

#### *POJO(Plain Old Java Object) 클래스
~~~
: EJB를 사용하면서 생산성, 성능이 좋지 않고 복잡한 기술의 단점을 보완하기 위해 나옴. 
[EJB에서 제공하는 엔터프라이즈 서비스와 기술+애플리케이션 개발이 가진 특징과 장점]

특정 규약이나 환경에 종속x , 객체지향 원리에 충실
코드 간결, 자동화 테스트에 유리, 객체지향적 설계의 자유로움.
라이브러리나 프레임워크로부터 강제받지 않는 객체.

->하이버네이트, 스프링
=>각각의 POJO는 특정 기술과 스펙에서 독립적이고 의존관계에 있는 다른 POJO와 느슨한 결합을 갖는다.
(최소한의 인터페이스만 공유, 유연한 변경 가능성 고려)
cf) 코드 p.54 참조
~~~

#### *	설정 메타정보
~~~
:POJO 클래스 중에 애플리케이션에서 사용할 것을 선정해 IoC 컨테이너가 제어할 수 있도록 적절한 메타정보를 제공해야함.
:bean 객체를 어떻게 만들고 어떻게 동작하게 할 것인지에 대한 정보.
BeanDefinition 인터페이스로 표현하는 순수한 추상 정보( XML (x))

Ex)  <bean  id=”…” class=”…”>
        <property name=”…” value=”…”/> 
</bean>

• 빈아이디， 이름， 별칭: 빈오브젝트를 구분할수있는식별자
• 클래스 또는 클래스 이름: 빈으로 만들 POJO 클래스 또는 서비스 클래스 정보
• 스코프: 싱글톤， 프로토타입과 같은 빈의 생성 방식과 존재 범위
• 프로퍼티 값 또는 참조: 미에 사용할 프로퍼티 이름과 값 또는 참조하는 빈의 이름
• 생성자 따라미터 값 또는 참조:01 에 시용할 생성자 파라미터 이름과 값 또는 참조할 빈의 이름
• 지연된 로딩 여부， 우선 빈 여부， 자동와이어링 여부， 부모 빈 정보， 빈팩토리 이름 등

~~~

### 1.1.2	IoC 컨테이너의 종류와 사용방법
~~~
종류 
1.StaticApplicationContext : 코드를 통해 빈 메타 정보를 등록할 때 사용.(학습테스트용)

2.GenericApplicationContext : 가장 일반적인 애플리케이션 컨텍스트 구현 클래스(실전용)
XML 같은 외부의 리소스에 있는 빈 설정 메타 정보를 리더(BeanDefinitionReader 인터페이스)를 통해 
읽어들여 메타정보로 전환하여 사용,
리더를 통해 메타정보를 load한 후 애플리케이션 컨텍스트를 refresh() 메소드를 한번 호출하면
애플리케이션 컨텍스트가 필요한 초기화 작업을 수행함.

=>보통 개발자는 직접 이용 x
->테스트시에 테스트 클래스에 @ContextConfiguration(locations=”~.xml”)어노테이션을 이용해 
바로 XML 파일 초기화하여 테스트 내에서 사용가능함

3.GenericXmlApplicationContext: GenericApplicationContext와 같은 데XmlBeanDefinitionReader와 결합해 
XML 파일을 읽어들이고 refresh() 를 통해 초기화 하는 것까지 한줄로 끝낼 수 있음. 
XML파일로 설정을 만들고 애플리케이션 컨텍스트에서 XML을 읽어서 사용하는 코드를 시험삼아 만들 때 적절.
-> XML 파일의 경로가 있어 좀 더 편하게 XML을 로딩할 수 있음.

4.WebApplicationContext: 가장 많이 사용하는 애플리케이션 컨텍스트.
그 중 많이 사용 되는 건 Xml 설정 파일을 사용하도록 만들어진 XmlWebApplicationContext임.
웹 애플리케이션에서는 미리 애플리케이션 컨텍스트를 생성해 놓고 클라이언트 요청이 들어오면
main() 역할을 해주는 서블릿을 getBean()으로 가져와 정해진 메소드를 실행시켜줌.

Main() 메소드 안에서 애플리케이션 컨텍스트를 만들어 메타정보을 읽어 POJO빈을 요청해 메소드 실행
=> DI 방식으로 서블릿이 대신 동작해줌.

===> DispatcherServlet (web.xml에 등록)

~~~

### 1.1.3	IoC 컨테이너 계층구조
~~~
한 개 이상의 IoC 컨테이너인 경우 ===> 트리 모양의 계층 구조

부모 컨텍스트에게만 빈 검색을 요청함.(자식 컨텍스트는 요청하지 못함)
1.일부 빈만 변경 가능하도록 만들고 싶을 때
2.여러 애플리케이션 컨텍스트가 공유하는 설정을 만들기 위해 사용.

GenericXmlApplicationContext: XML을 사용하는 루트 컨텍스트를 만들 때만 사용하는 클래스.
GenericApplicationContext: 세밀한 컨텍스트 설정을 위해 이용.

~~~

### 1.1.4 웹 애플리케이션의 IoC 컨테이너 구성

#### * 프론트 컨트롤러 패턴 : 몇 개의 서블릿이 중앙 집중식으로 모든 요청을 다 받아서 처리하는 방식
~~~
1.스프링에서 프론트 컨트롤러 패턴을 사용함.
2.스프링 웹 애플리케이션에 사용되는 서블릿 숫자는 하나이거나 많아야 2 ~ 3개.


* 웹 애플리케이션 안에서 동작하는 IoC 컨테이너는 두 가지 방법으로 만들어진다. 
1)스프링 애플리케이션 요청을 처리하는 서블릿 안에서 만들어지는 것
2)웹 애플리케이션 레벨에서 만들어지는 것
( 이 외는 엔터프라이즈 애플리케이션 레벨에 두는 방법이 있고, 위 2가지 방법은 웹 모듈 안에 컨테이너를 두는 방법 )
=> 일반적으로 두 가지 방법을 모두 사용하여 컨테이너를 만듦
~~~

#### * 웹 애플리케이션의 컨텍스트 계층 구조
~~~
 -웹 애플리케이션 레벨에 등록되는 컨테이너는 보통 루트 웹 애플리케이션 컨텍스트라 한다. 
 이 컨텍스트는 서블릿 레벨에 등록되는 컨테이너들의 부모 컨테이너가 되고,  
 계층구조 내에서 가장 최상단에 위치한 루트 컨텍스트가 된다.
 
- 서블릿들이 공유하여 사용하는 공통적인 빈들은 웹 애플리케이션 레벨의 컨텍스트에 등록하여
 서블릿 별로 중복하여 사용하는 것을 방지할 수 있다.
 
- 그러나 보통 일반적으로 스프링 애플리케이션의 프론트 컨트롤러 역할을 하는 서블릿은 하나만 두고 사용한다. 

-하나의 서블릿이 모든 요청을 처리하는데 왜 계층 구조 사용? 
=>프레젠테이션 계층에서 스프링 외의 기술을 사용할 수 있기 때문이다. 
(예) 스프링 외의 웹 프레임워크, WebService/AJAX, JSP/Servlet
이러한 스프링 외의 기능에서 루트 애플리케이션 컨텍스트로 접근이 가능하다! 
즉, 루트 애플리케이션에서 사용하는 공유 빈들을 가져와 사용할 수 있다!

WebApplicationContextUtils.getWebApplicationContext(ServletContext sc)

이러한 계층 구조로 분리하여 애플리케이션 컨텍스트를 구성해두면 웹 기술 확장, 변경, 조합이 용이해지므로 
당장에 스프링 서블릿이 하나만 사용되도 이러한 구조로 만들어두는 것이 권장된다.
~~~

#### * 웹 애플리케이션의 컨텍스트 구성방법
~~~
1.서블릿 컨텍스트와 루트 애플리케이션 컨텍스트 계층구조
- 가장 많이 사용
- 스프링 웹 기술을 사용하는 경우,
 웹 관련 빈: 서블릿의 컨텍스트 / 나머지: 루트 애플리케이션 컨텍스트에 등록
- 기타 웹 프레임 워크나 HTTP 요청을 통해 동작하는 각종 서비스를 함께 사용

2.루트 애플리케이션 컨텍스트 단일구조
- 스프링 웹기술 사용하지 않거나 서드파티 웹 프레임워크나 서비스 엔진만 사용해 프레젠테이션 계층을 만들 때
스프링 서블릿을 둘 필요가 없어 서블릿 애플리케이션 컨텍스트도 사용하지 않음.
- 루트 애플리케이션 컨텍스트만 등록.

3.서블릿 컨텍스트 단일구조
- 스프링 웹 기술 사용.
- 서블릿 컨텍스트가 스스로 루트 컨텍스트가 되어 모든 빈을 다 등록. 단순한 설정을 선호할 때사용하는 방법.
~~~

#### *루트 애플리케이션 컨텍스트 등록
~~~
 - 가장 간단한 방법은 서블릿의 이벤트 리스너를 등록.
  web.xml파일 안에 ContextLoaderListener 등록.
- 루트 애플리케이션 컨텍스트는 웹 애플리케이션의 
  WEB-INF 폴더의 applicationContext.xml 파일을 디폴트 설정 파일로 사용한다.
- 디폴트 XML 설정파일 위치는 <context-param>에서
  contextConfigLocation 으로 파라미터 선언을 해주는 것으로 바꿀 수 있다.

~~~

#### * 서블릿 애플리케이션 컨텍스트 등록
~~~
DispatcherServlet: 스프링의 웹 기능을 지원하는 프론트 컨트롤러 서블릿.
			  Web.xml에 등록해서 사용.
			  서블릿이 초기화 될 때 자신만의 컨텍스트를 생성하고 초기화함.

- <Servlet-name> : 네임스페이스는 서블릿 단위로 만들어지는 컨텍스트를 구분하는 키
                  네임스페이스 =>  ‘지정한 서블릿 이름’-servlet
                  디폴트 설정파일 규칙=>  '/WEB-INF/ ’ + 서블릿네임스페이스 + ' .xml ’
- <load-on-startup> : 서블릿 컨테이너가 등록된 서블릿을 언제 만들고 초기화할지, 
                      순서가 어떻게 되는지 지정하는 정수값(작은 수를 우선적, 보통 1 )
                      생략, 음의 정수-임의로 정한 시점에서 만들어지고 초기화
                      0이상의 값-웹애플리케이션이 시작되는 시점에서 서블릿로딩, 초기화
~~~

## 1.2 IoC/DI를 위한 빈 설정 메타 정보 작성
 ~~~
-빈을 만들기 위한 설정 메타 정보는 파일이나 애노테이션 같은 리소스로부터 
 전용리더를 통해 읽혀서 BeanDefinition 타입의 오브젝트로 변환된다. 
 이 BeanDefinition 정보를 IoC컨테이너가 활용하는 것이다.
~~~

### 1.2.1 빈 설정 메타 정보
~~~
BeanDefinition에는 IoC컨테이너가 빈을 만들 때 필요한 핵심정보가 담겨있다.   
 (표1-1 참고)
 ~~~

### 1.1.2 빈 등록 방법
~~~
XML문서, 프로퍼티 파일, 소스코드 애노테이션과 같은 외부 리소스로 빈 메타 정보를 작성하고 
이를 적절한 리더나 변환기를 통해 애플리케이션 컨텍스트가 사용할 수 있는 정보로 변환해주는 방법을 사용.

1.XML: <bean> 태그	
-스프링 빈 메타정보의 거의 모든 항목을 지정가능, 세밀한 제어 가능
->Hello 빈의 printer 프로퍼티에 StringPrinter 클래스로 내부 빈을 선언한 예 
DI이긴 하지만 특정 빈과 강한 결합을 가지고 등록되는 경우 내부 빈 사용.

2.XML: 네임스페이스와 전용 태그

3.Stereo type annotation과 bean scanner
-@Component 어노테이션 또는 @Component를 메타 어노테이션으로 가진 어노테이션이 부여된 클래스를 
빈 스캐너의 디폴트 필터는 인식하고, 해당 클래스를 빈으로 등록하게 된다. 
디 폴트 필터에 적용 되는 어노테이션을 스프링에서는 스테레오 타입 어노테이션이라고 부른다.

4.@Configuration 클래스의 @Bean 메소드

5.일반 빈 클래스의 @Bean 메소드
 -@Configuration이 붙지 않은 @Bean 메소드는 @Configuration 클래스의 @Bean과
 미묘한 차이가 있다.	.
~~~






